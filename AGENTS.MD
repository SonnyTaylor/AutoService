# Project Overview

AutoService is a Windows diagnostic toolkit built with **Tauri (Rust backend) + vanilla JavaScript frontend**. It orchestrates portable maintenance tools, runs stress tests, and generates comprehensive reports‚Äîdesigned for computer repair technicians to run from USB drives.

## Essential Commands

### Development

```powershell
# Install dependencies
pnpm install

# Run in development mode (hot-reload frontend + Rust, only works in an admin terminal)
pnpm tauri dev

# Frontend only (without Tauri, this is rarely used)
pnpm dev

# Run tests
pnpm test
```

### Building

```powershell
# Build production executable (creates portable .exe + data/ folder)
pnpm tauri build
# Output: src-tauri/target/release/autoservice.exe
```

### Python Runner Development

```powershell
# Install Python dependencies
pip install -r runner/requirements.txt

# Test individual service
python runner/service_runner.py runner/fixtures/test_bleachbit.json

# The build process automatically compiles service_runner.exe via PyInstaller
# In dev mode, falls back to Python interpreter if exe is missing
```

## Architecture Overview

### Three-Layer Design

1. **Frontend (Vanilla JS + Vite)**
   - Hash-based SPA router in `src/main.js`
   - Modular pages in `src/pages/**/` with `initPage()` controllers
   - No framework dependencies - pure vanilla JS with lit-html templating

2. **Tauri Backend (Rust)**
   - IPC command handlers in `src-tauri/src/*.rs`
   - 40+ commands for file I/O, system info, program/script management
   - AppState holds `data_dir` path (Arc<PathBuf>)

3. **Python Service Runner**
   - Standalone `runner/service_runner.exe` (PyInstaller-packaged)
   - Executes automation tasks asynchronously
   - Streams logs to frontend via stderr markers
   - Falls back to `python runner/service_runner.py` in dev

### Data Flow: Task Execution

```
Frontend (Builder)
  ‚Üí Generate JSON plan with task definitions
  ‚Üí invoke("start_service_run", plan)

Rust Backend
  ‚Üí Spawn Python runner subprocess
  ‚Üí Stream stderr lines to frontend via events

Python Runner
  ‚Üí Execute tasks sequentially
  ‚Üí Emit TASK_START/TASK_OK/TASK_FAIL markers
  ‚Üí Return final JSON report to stdout

Frontend (Results)
  ‚Üí Render technical and customer-facing reports
  ‚Üí Auto-save if enabled
```

## Critical Patterns

### Service Handler System

**All service logic lives in self-contained modules** at `src/pages/service/handlers/[service_id]/`.

Each handler exports up to 4 components:

```javascript
// src/pages/service/handlers/example_service/index.js

// 1. DEFINITION (required) - Service metadata and task builder
export const definition = {
  id: "example_service",           // Matches Python handler
  label: "Example Service",         // UI display name
  group: "Diagnostics",             // Category for grouping
  toolKeys: ["required-tool"],      // External tool dependencies

  async build({ params, resolveToolPath, getDataDirs }) {
    const toolPath = await resolveToolPath("required-tool");
    return {
      type: "example_service",      // Must match handler ID
      executable_path: toolPath,
      params                         // Task-specific parameters
    };
  }
};

// 2. TECH RENDERER (required) - Detailed technical view
export function renderTech({ result, index }) {
  return html`<div class="card">
    ${kpiBox("Status", result.summary.status)}
  </div>`;
}

// 3. CUSTOMER METRICS - Customer-friendly summary
export function extractCustomerMetrics({ summary, status }) {
  if (status !== "success") return null;
  return buildMetric({
    icon: "üîß",
    label: "Service Result",
    value: summary.result
  });
}

// 4. PRINT CSS - Service-specific print styles
export const printCSS = `.example-service { ... }`;
```

**Handlers automatically integrate** with catalog, renderers, and print systems‚Äîno editing scattered files.

### Adding a New Service

**Step 1: Python Backend**

```python
# runner/services/new_service.py
def run_new_service(task: Dict[str, Any]) -> Dict[str, Any]:
    return {
        "task_type": "new_service",
        "status": "success" | "error" | "warning",
        "summary": {
            "human_readable": {...},  # UI display data
            "results": {...}          # Raw technical data
        },
        "duration_seconds": 123.45
    }
```

**Step 2: Register Python Handler**

```python
# runner/service_runner.py
from services.new_service import run_new_service

TASK_HANDLERS = {
    ...,
    "new_service": run_new_service
}
```

**Step 3: Create Frontend Handler**

```powershell
# Copy template
cp -r src/pages/service/handlers/_TEMPLATE src/pages/service/handlers/new_service
```

**Step 4: Implement Handler** (`src/pages/service/handlers/new_service/index.js`)

- Export `definition` with `id`, `label`, `group`, `toolKeys`, `build()`
- Export `renderTech()` function for technical display
- Export `extractCustomerMetrics()` for customer summary (optional)
- Export `printCSS` for service-specific print styles (optional)

**Step 5: Register Handler**

```javascript
// src/pages/service/handlers/index.js
import * as newService from "./new_service/index.js";

const HANDLERS = {
  ...,
  new_service: newService
};
```

Done! The handler will automatically appear in the service catalog.

### Portable Data Directory Pattern

**All external tools** live in `data/programs/<ToolName - Version>/`

**Critical rules:**

- Executable paths in `data/settings/programs.json` are **relative to data/** for USB portability
- Rust backend auto-converts absolute paths to relative on save
- **Never hard-code tool paths** - always use `resolveToolPath()`

```javascript
// ‚ùå WRONG - Hard-coded path breaks portability
const toolPath = "C:/data/programs/BleachBit/bleachbit.exe";

// ‚úÖ CORRECT - Dynamic resolution
const toolPath = await resolveToolPath("bleachbit");
if (!toolPath) throw new Error("BleachBit not found");
```

### Frontend IPC Communication

**Frontend ‚Üí Rust**: Use `window.__TAURI__.core.invoke(commandName, args)`

```javascript
// Common IPC patterns
const settings = await window.__TAURI__.core.invoke("load_app_settings");
const programs = await window.__TAURI__.core.invoke("list_programs");
await window.__TAURI__.core.invoke("save_program", { program });
const systemInfo = await window.__TAURI__.core.invoke("get_system_info");
```

**Rust Commands**: Annotate with `#[tauri::command]`, register in `src-tauri/src/lib.rs`

```rust
#[tauri::command]
fn my_command(state: tauri::State<AppState>) -> Result<String, String> {
    // Implementation
}

// In lib.rs builder:
.invoke_handler(tauri::generate_handler![
    my_command,
    // ... other commands
])
```

### Real-Time Log Streaming

Python runner emits structured markers to stderr for live UI updates:

```python
# CRITICAL: Always flush after markers for real-time updates
sys.stderr.write("TASK_START: service_name\n")
sys.stderr.flush()  # Without this, UI receives updates in batches

# ... do work ...

sys.stderr.write("TASK_END: service_name | SUCCESS\n")
sys.stderr.flush()
```

Frontend listens to `service_runner_line` events in `src/pages/service/runner.js` and parses these markers.

### Tool Resolution & Availability

```javascript
// Get tool availability (cached in sessionStorage)
const toolStatuses = await getToolStatuses();
// Returns: [{ key, name, exists, path, hint }, ...]

// Resolve specific tool path
const toolPath = await resolveToolPath(["primary-tool", "fallback-tool"]);
if (!toolPath) {
  console.warn("Tool not available");
}
```

Backend checks existence of key tools (bleachbit, furmark, heavyload, sfc, dism, smartctl, etc.) and returns paths + hints for missing tools.

## State Management

### SessionStorage (transient, cleared on tab close)

- `service.pendingRun` - Queued tasks from builder page
- `service.finalReport` - Completed service run results
- `tool.statuses.v1` - Cached tool availability

### LocalStorage (persistent)

- `service.finalReport` - Fallback for report persistence
- Business settings and app configuration

**State Flow**: Builder ‚Üí sessionStorage ‚Üí Runner ‚Üí sessionStorage ‚Üí Results page

## Print System

### Technician Reports

- **Purpose**: Detailed technical reports with full diagnostic data, charts, raw outputs
- **Location**: `src/pages/service/results/print/tech.js`
- **Includes**: Task results, performance charts, system info, execution logs

### Customer Reports

- **Purpose**: Simplified, customer-friendly summaries
- **Location**: `src/pages/service/results/print/customer.js`
- **Includes**: High-level metrics, security findings, maintenance work, recommendations

**Metric Card Structure**:

```javascript
{
  icon: "üõ°Ô∏è",                    // Emoji indicator
  label: "Security",              // Category name
  value: "Clean",                 // Primary result
  detail: "No threats found",     // Additional context
  variant: "success" | "info",    // Styling
  items: ["Scanned 1,247 files"]  // Optional breakdown
}
```

## Python Service Return Schema

**All Python services must return standardized schema**:

```python
{
    "task_type": "service_id",      # Matches handler ID
    "status": "success" | "error" | "warning",
    "summary": {
        "human_readable": {...},    # UI display data
        "results": {...}            # Raw technical data
    },
    "output": "...",                # Optional: stdout/stderr
    "duration_seconds": 123.45
}
```

## Common Pitfalls & Solutions

‚ùå **Hard-coding tool paths**: `"programs/BleachBit/bleachbit.exe"`
‚úÖ **Use dynamic resolution**: `await resolveToolPath('bleachbit')`

‚ùå **Buffered Python logs**: UI receives updates only after task completion
‚úÖ **Explicit flushing**: `sys.stderr.flush()` after every log marker

‚ùå **Absolute paths in programs.json**: Breaks portability when USB drive letter changes
‚úÖ **Relative paths**: Rust backend auto-normalizes to `data/programs/...`

‚ùå **Missing tool detection**: Tasks execute blindly without checking availability
‚úÖ **Pre-check availability**: Builder UI grays out unavailable services using `toolKeys`

‚ùå **Editing scattered files for new services**: Modifying catalog.js, renderers.js, etc.
‚úÖ **Self-contained handlers**: Everything in `handlers/[service_id]/index.js`

## Project Structure Reference

```
src/
‚îú‚îÄ‚îÄ main.js                 # Router - loads pages dynamically
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ service/           # Main automation workflow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ catalog.js     # Service registry (imports handlers)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builder.js     # Task queue builder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ runner.js      # Python runner orchestration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ results/       # Report rendering & printing
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers/      # Service modules (self-contained)
‚îÇ   ‚îú‚îÄ‚îÄ system-info/       # Hardware/OS info
‚îÇ   ‚îú‚îÄ‚îÄ programs/          # Program management
‚îÇ   ‚îú‚îÄ‚îÄ scripts/           # Script catalog
‚îÇ   ‚îî‚îÄ‚îÄ settings/          # App configuration
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ business.js               # Business settings & technician mode
    ‚îú‚îÄ‚îÄ notification-sounds.js    # Notification sound library
    ‚îú‚îÄ‚îÄ reports.js                # Report utilities
    ‚îú‚îÄ‚îÄ service-metadata-modal.js # Service metadata prompts
    ‚îú‚îÄ‚îÄ tools.js                  # Tool status caching & resolution
    ‚îî‚îÄ‚îÄ settings/                 # Settings utilities

src-tauri/src/
‚îú‚îÄ‚îÄ lib.rs                 # Command handlers & app setup
‚îú‚îÄ‚îÄ state.rs               # AppState (data_dir)
‚îú‚îÄ‚îÄ models.rs              # Data structures (25+ types)
‚îú‚îÄ‚îÄ programs.rs            # Program management
‚îú‚îÄ‚îÄ scripts.rs             # Script execution
‚îú‚îÄ‚îÄ system.rs              # System info collection
‚îî‚îÄ‚îÄ reports.rs             # Report persistence

runner/
‚îú‚îÄ‚îÄ service_runner.py      # Main orchestrator
‚îú‚îÄ‚îÄ sentry_config.py       # Sentry setup
‚îú‚îÄ‚îÄ services/              # Service implementations
‚îÇ   ‚îú‚îÄ‚îÄ bleachbit_service.py
‚îÇ   ‚îú‚îÄ‚îÄ sfc_service.py
‚îÇ   ‚îî‚îÄ‚îÄ ...               # One file per task type
‚îî‚îÄ‚îÄ fixtures/              # Test JSON files

data/                      # Portable data folder (travels with EXE)
‚îú‚îÄ‚îÄ programs/              # External tool executables
‚îú‚îÄ‚îÄ settings/              # JSON configs
‚îú‚îÄ‚îÄ reports/               # Generated reports
‚îú‚îÄ‚îÄ resources/bin/         # service_runner.exe
‚îî‚îÄ‚îÄ logs/                  # Execution logs
```

## Sentry Error Tracking

### Configuration

- **Python**: `runner/sentry_config.py` - Python SDK with task lifecycle tracking

**Release Format**: `autoservice@{version}` (e.g., `autoservice@0.4.0`)

## Development Notes

- **No TypeScript**: Project uses vanilla JS with JSDoc annotations for IDE hints
- **CSS Architecture**: Global styles in `src/styles/`, component-specific styles inlined
  - **`core.css`**: Main CSS file containing color variables, typography, and global styles
  - **Page-specific CSS**: Individual files for each major section (service.css, programs.css, settings.css, etc.)
  - **Component styles**: Inlined within page components for self-contained styling
- **Frontend Libraries**: Minimal dependencies (Fuse.js, SortableJS, ApexCharts, Tone.js, lit-html)
- **Rust Crates**: sysinfo, battery, wgpu for hardware detection
- **Python Style**: PEP 8 compliant, type hints encouraged
- **Package Management**: Use pnpm packages wherever possible for easier coding.

**Current Setup**:

- `pnpm test` runs Node.js native test runner
- Python fixtures in `runner/fixtures/test_*.json` for isolated service testing
- Manual UI testing via Service ‚Üí Run workflow

**Testing Individual Services**:

```powershell
# Test Python service in isolation
python runner/service_runner.py runner/fixtures/test_bleachbit.json

# Check output
cat data/reports/*.json
```

## Build System

### Frontend (Vite)

- Target: Chrome 105 (Tauri webview)
- Output: `dist/` folder embedded in Tauri app

### Backend (Cargo + Tauri)

- Compiles Rust ‚Üí embeds frontend from `dist/`
- Windows UAC elevation requested in `build.rs`
- Output: Single portable EXE

### Python Runner (PyInstaller)

- Triggered during `cargo build` via `src-tauri/build.rs`
- Checks if source is newer than existing exe
- Bundles to single-file `data/resources/bin/service_runner.exe`
- Falls back to Python interpreter if exe missing (dev flexibility)

## Key Files

| File | Purpose |
|------|---------|
| `src/main.js` | Hash router, page loader |
| `src/pages/service/handlers/index.js` | Handler registry |
| `src/pages/service/catalog.js` | Service definitions (from handlers) |
| `src-tauri/src/lib.rs` | Tauri command registrations |
| `runner/service_runner.py` | Task dispatcher |
| `runner/services/*.py` | Individual service implementations |
| `data/settings/programs.json` | User-managed tool definitions |
| `.github/copilot-instructions.md` | Extended AI development guide |

## Extension Points

### Adding a New Page

1. Create `src/pages/[page-name]/[page-name].html`
2. Create `src/pages/[page-name]/index.js` with `initPage()` export
3. Update `src/main.js` router if needed

### Adding a New Tauri Command

1. Create handler function in `src-tauri/src/[module].rs`
2. Annotate with `#[tauri::command]`
3. Register in `src-tauri/src/lib.rs` handler list

### Adding a New Tool

1. Place tool in `data/programs/[ToolName - Version]/`
2. Add entry via Programs page UI
3. Tool becomes available via `resolveToolPath()` and `getToolStatuses()`
